# Кодировка в x264

После открытия нужного файла, первым делом включаем полный процессинг аудио-потока для его последующего сжатия (`Audio -> Full processing mode`):

![x264_coding_1.png](assets%2Fimg%2Fchapter_3%2Fx264_coding_1.png)

Пользуясь стрелками отсекаем лишние фрагменты:

![x264_coding_2.png](assets%2Fimg%2Fchapter_3%2Fx264_coding_2.png)

Производим дальнейшие необходимые манипуляции (деинтерлейс, кроп, эффекты).

Далее сохраняем видео (`File -> Save video…`)

И настраиваем кодеки соответственно **варианту №2** (сжатый исходник): 

![x264_coding_3.png](assets%2Fimg%2Fchapter_3%2Fx264_coding_3.png)

![x264_coding_4.png](assets%2Fimg%2Fchapter_3%2Fx264_coding_4.png)

Ждём окончания кодирования.

> [!TIP]
> **Если необходимо скодировать сразу несколько файлов**, не забываем о существовании batch-кодирования!

`File -> Queue batch operation -> Save video…`

![x264_coding_5.png](assets%2Fimg%2Fchapter_3%2Fx264_coding_5.png)

После открываем следующее видео, и сохраняем его аналогичным образом.

В конце открываем `File -> Job control…` и начинаем кодирование (Start):

![x264_coding_6.png](assets%2Fimg%2Fchapter_3%2Fx264_coding_6.png)

# Обработка и кодирование для загрузки на интернет-площадки

> [!IMPORTANT]
> Данная рубрика требует более глубоких знаний и понимания теории работы AviSynth и плагинов обработки видео

## Требуемый софт

1.	[Topaz Video AI](https://rutracker.org/forum/viewtopic.php?t=6505918)
2.	[MeGUI](https://www.videohelp.com/software/MeGUI)
3.	[StaxRip](https://github.com/staxrip/staxrip)
4.	[AviSynth+](https://github.com/AviSynth/AviSynthPlus)

## Плагины

1.	[LSMASHSource](http://avisynth.nl/index.php/LSMASHSource)
2.	[QTGMC](http://avisynth.nl/index.php/QTGMC)
3.	[VideoTek](https://forum.doom9.org/showthread.php?p=1832763#post1832763)
4.	[TemporalDegrain2](http://avisynth.nl/index.php/TemporalDegrain2)
5.	[MCTemporalDenoise](http://avisynth.nl/index.php/MCTemporalDenoise)
6.	[CCD (Camcorder Color Denoise)](https://forum.doom9.org/showthread.php?t=181549)
7.	[RemoveDirt (зеркало)](http://avisynth.nl/index.php/RemoveDirt)

## AviSynth скрипты

8. [RemoveDirtMC.avsi](assets%2Fscripts%2FRemoveDirtMC.avsi)
8.	[Stab](http://avisynth.nl/index.php/Stab)
9.	[ColorMatrix](http://avisynth.nl/index.php/ColorMatrix)

> [!NOTE]  
> Недостающее можно скачать [тут](http://avisynth.nl/index.php/External_filters)

Шаблон универсального скрипта [vidachestvo.avs](assets%2Fscripts%2Fvidachestvo.avs)

## Этап 1. Импорт

Открываем скрипт в VirtualDub 2 x64. Указываем имя файла сырого исходника (720x576 Lagarith YUY2, аудио 48000Hz 16bit), опционально указываем аудиофайл, если делается обработка/реставрация/ремастеринг звука. 

> [!CAUTION]
> Пути и имена не должны содержать кириллицу!

Кропаем изображение до 704 пикселей по ширине, выравнивая полезную часть кадра по центру. Обрезаем лишний хронометраж. 

![import_1.png](assets%2Fimg%2Fchapter_3%2Fimport_1.png)

При необходимости также:

* Синхронизируем аудио, если оно захватывалось с внешней карты
* Выбираем правильный порядок полей для прогрессивного источника/телекино
* Делаем нарезку/монтаж
* Подгоняем уровни. Пики канала яркости должны едва касаться желтых областей

![import_2.png](assets%2Fimg%2Fchapter_3%2Fimport_2.png)

(Уровень черного обычно приходится подкручивать у плохих перегонов с кинопленки, у видео все более-менее нормально с этим)

Если источник в целом прогрессивный, но имеет интерлейсные участки, например, монтажные переходы и т.д., то целесообразно сделать местный деинтерлейс на этом этапе. Например, таким образом:

`deint = AssumeTFF().QTGMC(Preset="Slower", SourceMatch=3, Lossless=2).SelectEven()`<br>
`ApplyRange(aaa, bbb, "Merge", deint, 1.0)` <br>
`ApplyRange(ccc, ddd, "Merge", deint, 1.0)`

Если попадаются кадры/участки с выпадением в одном поле, это правится аналогичным образом:

`fix = Separatefields().SelectEven().PointResize(704, 576)` или `.SelectOdd().
ApplyRange(aaa, bbb, "Merge", fix, 1.0)`

По такому же принципу можно осуществить любую другую “местную” обработку. Главное, не вставлять фильтры в `ApplyRange` если требуется обработать сразу много участков, это сильно замедляет обработку. Лучше создать отдельный клип с нужным набором фильтров и многократно использовать `Merge`.

Если будет производиться апскейл Топазом, сохраняем видео со сжатием Lagarith, цвет YUY2. В противном случае закомментируем строку `Prefetch(16) __END__` и продолжаем.

## Этап 2. Обработка для рипов

Необходимо подобрать такие настройки шумоподавления, чтобы максимально снизить шум, но минимально затронуть полезные детали изображения. Приоритет отдается детализации, даже если не получается достаточно снизить шум.

![processing_1.png](assets%2Fimg%2Fchapter_3%2Fprocessing_1.png)

Проверить, что было удалено шумодавом можно раскомментировав строку

`#Overlay(raw, mode="difference")`

Если исходник прогрессивный, для небольшого ускорения обработки (и, вероятно, повышения качества) можно раскомментировать строку `#src = raw` и закомментировать

`Interleave(Crop(0, 0, 704, 288), Crop(0, 288, 704, 288)).AssumeFieldBased().Weave().AssumeTFF()`

Для рипов в x264 и для исходников, оцифрованных с композита, нужно выбрать цветовую субдискретизацию 4:2:0 -

![processing_2.png](assets%2Fimg%2Fchapter_3%2Fprocessing_2.png)

На данном этапе можно кодировать видео для рипа с неквадратными пикселями.

Если требуется прогрессивный рип с квадратными пикселями, закомментируем строку `Prefetch(16) __END__ `и продолжаем.

Выполняем деинтерлейс **[QTGMC](http://avisynth.nl/index.php/QTGMC)**. Для неответственных рипов можно воспользоваться встроенным шумодавом `EZDenoise` и закомментировать весь предыдущий блок команд, кроме преобразования в 4:2:0. В таком случае пресет можно выбрать “medium”, будет быстрее кодироваться, но похуже качеством.

![processing_3.png](assets%2Fimg%2Fchapter_3%2Fprocessing_3.png)

У изображения, имеющего исходно аналоговую природу, к примеру записанного с телекамеры, а не выведенного с компьютера, с вероятностью 99% полезная ширина кадра будет составлять 702-704 пикселя (отсчёта). Для более точного сохранения пропорций, и чтобы избавиться от тонких черных полос по бокам, необходимо обрезать изображение. Некоторые цифровые источники также выводят кадр шириной 702 отсчета, но часто встречаются 704, поэтому нужно определять нужное значение индивидуально. Только стоит помнить, что кадр не может быть уже 702 и шире 706 отсчетов (согласно [ITU-R BT.601](https://www.itu.int/rec/R-REC-BT.601/), [BT.1700](https://www.itu.int/rec/R-REC-BT.1700/en)). Если после обрезки все равно остаются черные полосы, их следует либо оставить, либо кропнуть изображение уже после ресайза до 768x576

## Этап 2.5. Апскейл для YouTube

На данный момент рекомендуемая версия Topaz Video AI 4.2.2. Если ни одна из опробованных моделей не обеспечит желаемый результат, можно воспользоваться Topaz Video Enhance AI 2.6.4 (но иметь в виду про [нюанс](#Копилка-знаний)), в ней доступны более старые модели.

Устанавливаем такие настройки вывода:

![upscale_1.png](assets%2Fimg%2Fchapter_3%2Fupscale_1.png)


Открываем сохраненный на первом этапе видеофайл (версия 2.6.4 умеет открывать avs скрипты без сохранения промежуточного видеофайла).

Устанавливаем такие настройки обработки:

![upscale_2.png](assets%2Fimg%2Fchapter_3%2Fupscale_2.png)

(пункт “Frame Rate - 50 FPS” будет доступен для выбора в последнюю очередь)

Необходимо протестировать апскейл на “сложном” участке видео -

![upscale_3.png](assets%2Fimg%2Fchapter_3%2Fupscale_3.png)

![upscale_4.png](assets%2Fimg%2Fchapter_3%2Fupscale_4.png)

Можно поиграться с настройками обработки:

![upscale_5.png](assets%2Fimg%2Fchapter_3%2Fupscale_5.png)

![upscale_6.png](assets%2Fimg%2Fchapter_3%2Fupscale_6.png)

Либо выбрать другую модель:

![upscale_7.png](assets%2Fimg%2Fchapter_3%2Fupscale_7.png)

* **Dione** подходит для интерлейсных исходников среднего качества, хорошо чистит, но обеспечивает меньшую детализацию, не имеет настроек.
* **Iris** подходит для обработки грязных исходников низкого качества, но результат может получиться излишне “пластиковый”, с артефактами. Применять с осторожностью.
* **Proteus** наиболее универсальная модель, подходящая для большинства исходников.

При необходимости можно обработать видео несколькими моделями и смешать результат.

Если на этапе импорта не было применено ничего кроме кропа и обрезки, можно не сохранять промежуточный видеофайл, а импортировать исходник непосредственно в Топаз. Эти операции можно сделать на месте:

![upscale_8.png](assets%2Fimg%2Fchapter_3%2Fupscale_8.png)

![upscale_9.png](assets%2Fimg%2Fchapter_3%2Fupscale_9.png)

![upscale_10.png](assets%2Fimg%2Fchapter_3%2Fupscale_10.png)

Далее отрендеренный видеофайл вставляется в скрипт:

![upscale_11.png](assets%2Fimg%2Fchapter_3%2Fupscale_11.png)

LWLibavVideoSource предварительно индексирует видеофайл при открытии, поэтому придется подождать, либо работать с быстрого SSD.

Степень смешения в `Merge` можно регулировать. Хороший результат получается в диапазоне от 0.33 до 0.75.

Кроп по ширине до 702*2 выполняется на этом этапе, а не ранее.
Ресайз в итоговое разрешение обычно лучше делать с помощью алгоритма Lanczos, но в отдельных случаях лучше выглядит Sinc+Spline.

Для всякого малозначительного контента типа интервью, длительных видовых съемок, исходников с низкой четкостью и т.д. имеет смысл использовать разрешение 1440x1080 для снижения времени кодирования.

## Этап 3. Кодирование x264 рипа

Устанавливаем такие настройки MeGUI:

![x264_encode_1.png](assets%2Fimg%2Fchapter_3%2Fx264_encode_1.png)

![x264_encode_2.png](assets%2Fimg%2Fchapter_3%2Fx264_encode_2.png)

Настройки кодировщика следующие:

![x264_encode_3.png](assets%2Fimg%2Fchapter_3%2Fx264_encode_3.png)

![x264_encode_4.png](assets%2Fimg%2Fchapter_3%2Fx264_encode_4.png)

Для прогрессивных рипов `Interlaced Mode = None`

![x264_encode_5.png](assets%2Fimg%2Fchapter_3%2Fx264_encode_5.png)

![x264_encode_6.png](assets%2Fimg%2Fchapter_3%2Fx264_encode_6.png)

![x264_encode_7.png](assets%2Fimg%2Fchapter_3%2Fx264_encode_7.png)

Для прогрессивных рипов очистить `Custom Command Line`

Для рипов с квадратными пикселями `Force SAR = 1:1`

Кодировщик аудио - FLAC, со следующими настройками:

![x264_encode_8.png](assets%2Fimg%2Fchapter_3%2Fx264_encode_8.png)

Далее открываем avs скрипт, `AutoEncode -> Queue`

![x264_encode_9.png](assets%2Fimg%2Fchapter_3%2Fx264_encode_9.png)

При первом запуске будут автоматически скачаны все необходимые компоненты последней версии. 

> [!IMPORTANT]  
> Обновляться вручную с сервера не стоит, скачаются старые версии. Судя по всему, это такой баг в MeGUI 6666.

## Этап 3.5. Кодирование для YouTube

Целесообразно сохранить отдельный вариант скрипта для кодирования апскейла.

Программное кодирование HD будет очень медленное. Лучше использовать аппаратный кодировщик, а его недостатки компенсировать повышенным битрейтом. Например, H.265 (прим. друг. авт. — сомнительное решение, обработка ЦПУ хоть и более медленная, но более эффективная и позволяет добиться наилучшего качества изображения при меньшем битрейте).

Подойдут видеокарты [Nvidia](https://developer.nvidia.com/video-encode-and-decode-gpu-support-matrix-new) начиная с 1000 серии (кроме 1030), AMD начиная с 6000 серии, или Intel ARC. Самые свежие карты имеют кодер AV1, предпочтительнее использовать его.

Открываем скрипт в StaxRip, выставляем форматы видео и аудио, контейнер - mkv.

![YT_encoding_1.png](assets%2Fimg%2Fchapter_3%2FYT_encoding_1.png)

Настройки для Nvidia NVEnc следующие:

![YT_encoding_2.png](assets%2Fimg%2Fchapter_3%2FYT_encoding_2.png)

> [!TIP]
> Для YouTube вполне хватает 20Мбит VBR, но по желанию можно подобрать значение QP/QVBR для режима постоянного качества.

![YT_encoding_3.png](assets%2Fimg%2Fchapter_3%2FYT_encoding_3.png)

Если не указать цветовое пространство, YouTube по умолчанию использует **[bt.709](https://en.wikipedia.org/wiki/Rec._709)**, но для совместимости с другими платформами все же лучше его указать, иначе цвета получатся тусклыми — произойдёт неправильная интерпретация _limited range_ (16–235) как _full range_ (0–255).

Далее следует сохранить настройки в меню `File -> Save Project As Template`

Кодирование запускается путем `Add job -> Start`. Предварительно можно добавить в очередь несколько заданий.

Для экономии времени можно запустить параллельное кодирование x264 рипа и апскейла. Если оба задания запускаются из одной директории, то сначала необходимо открыть скрипт в StaxRip, а затем в MeGUI. Последовательность запуска кодирования уже значения не имеет.

## Дополнительно. Обработка перегонов с телекино

Для такого исходника:

![telecine_1.png](assets%2Fimg%2Fchapter_3%2Ftelecine_1.png)

Скрипт x264 рипа будет выглядеть следующим образом:

![telecine_2.png](assets%2Fimg%2Fchapter_3%2Ftelecine_2.png)

У фильмов, изначально смонтированных на кинопленке, в подавляющем большинстве случаев исходная частота кадров — 24. Апскейл уже не ограничен требованиями к SD видео, поэтому частоту кадров следует вернуть к оригинальной. Сделать это можно командой:

`AssumeFPS(24).ResampleAudio(50000).AssumeSampleRate(48000)`

Либо просто `AssumeFPS(24)` и импортировать заранее обработанную и растянутую аудиодорожку из отдельного файла.

Настройки в Топазе, соответственно, будут такие:

![telecine_3.png](assets%2Fimg%2Fchapter_3%2Ftelecine_3.png)

Скрипт для апскейла будет выглядеть примерно так:

![telecine_4.png](assets%2Fimg%2Fchapter_3%2Ftelecine_4.png)

`Stab` выдает лучший результат когда предварительно полностью обрезаны черные поля со всех сторон. Поскольку эта операция может привести к нарушению пропорций, нужно либо обрезать немного лишнего, либо постараться не запутаться и пересчитать итоговое разрешение для ресайза.

Порог чувствительности `RemoveDirtMC` следует подобрать таким образом, чтобы достаточное количество грязи было удалено, но при этом не пострадали резко движущиеся мелкие детали, например блики, пролетающие в кадре птицы, и т.п. Обычно, оптимальное значение лежит в диапазоне 15 – 45.

Для черно-белых фильмов в конец следует добавить фильтр `Grayscale()`, чтобы не кодировать шум и всякий мусор в канале цветности.

## Дополнительно. Обработка аудио

Требуемый софт:
- [Adobe Audition 3.0.1](https://rutracker.org/forum/viewtopic.php?t=5261216) 
- [iZotope RX](https://rutracker.org/forum/viewtopic.php?t=6575804)

_Under construction…_
